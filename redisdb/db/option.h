#pragma once

#include "logger.h"
#include "dbformat.h"
#include "snapshot.h"


// DB Contents are stored in a Set of blocks, each of which holds a
// sequence of key,value pairs.  Each block may be compressed before
// being stored in a file.  The following enum describes which
// compression method (if any) is used to compress a block.
enum CompressionType {
	// NOTE: do not change the values of existing entries, as these are
	// part of the persistent format on disk.
	kNoCompression = 0x0,
	kSnappyCompression = 0x1
};

class ShardedLRUCache;
// Options to control the behavior of a database (passed to DB::Open)
struct Options {
	// -------------------
	// Parameters that affect behavior

	// Comparator used to define the order of keys in the table.
	// Default: a comparator that uses lexicographic byte-wise ordering
	//
	// REQUIRES: The client must ensure that the comparator supplied
	// here has the same name and orders keys *exactly* the same as the
	// comparator provided to previous Open calls on the same DB.
	const Comparator* comparator;

	// If true, the database will be created if it is missing.
	// Default: false
	bool createifmissing;
	// If true, an error is raised if the database already exists.
	// Default: false
	bool errorifexists;
	// If true, the implementation will do aggressive checking of the
	// data it is processing and will stop early if it detects any
	// errors.  This may have unforeseen ramifications: for example, a
	// Corruption of one DB entry may cause a large number of entries to
	// become unreadable or for the entire DB to become unopenable.
	// Default: false
	bool paranoidchecks;

	// Any internal progress/error information generated by the db will
	// be written to info_log if it is non-null, or to a file stored
	// in the same directory as the DB Contents if info_log is null.
	std::shared_ptr<Logger> infolog;

	// If non-null, use the specified cache for blocks.
	// If null, leveldb will automatically create and use an 8MB internal cache.
	std::shared_ptr<ShardedLRUCache> blockcache;

	// Any internal progress/error information generated by the db will
	// be written to info_log if it is non-null, or to a file stored
	// in the same directory as the DB contents if info_log is null.
	std::shared_ptr<Env> env;

	// -------------------
	// Parameters that affect performance

	// Amount of data to build up in memory (backed by an unsorted log
	// on disk) before converting to a sorted on-disk file.
	//
	// Larger values increase performance, especially during bulk loads.
	// Up to two Write buffers may be held in memory at the same time,
	// so you may wish to adjust this parameter to control memory usage.
	// Also, a larger Write buffer will result in a longer recovery time
	// the Next time the database is opened.
	//
	// Default: 4MB
	size_t writebuffersize;

	// Number of Open files that can be used by the DB.  You may need to
	// increase this if your database has a large working Set (budget
	// one Open file per 2MB of working Set).
	//
	// Default: 1000
	int maxopenfiles;
	// Approximate size of user data packed per block.  Note that the
	// block size specified here corresponds to uncompressed data.  The
	// actual size of the unit read from disk may be smaller if
	// compression is enabled.  This parameter can be changed dynamically.
	//
	// Default: 4K
	size_t blocksize;

	// Number of keys between restart points for delta encoding of keys.
	// This parameter can be changed dynamically.  Most clients should
	// leave this parameter alone.
	//
	// Default: 16
	int blockrestartinterval;

	// Leveldb will Write up to this amount of bytes to a file before
	// switching to a new one.
	// Most clients should leave this parameter alone.  However if your
	// filesystem is more efficient with larger files, you could
	// consider increasing the value.  The downside will be longer
	// compactions and hence longer latency/performance hiccups.
	// Another reason to increase this parameter might be when you are
	// initially populating a large database.
	//
	// Default: 2MB
	size_t maxfilesize;

	// Compress blocks using the specified compression algorithm.  This
	// parameter can be changed dynamically.
	//
	// Default: kSnappyCompression, which gives lightweight but fast
	// compression.
	//
	// Typical speeds of kSnappyCompression on an Intel(R) Core(TM)2 2.4GHz:
	//    ~200-500MB/s compression
	//    ~400-800MB/s decompression
	// Note that these speeds are significantly faster than most
	// persistent storage speeds, and therefore it is typically never
	// worth switching to kNoCompression.  Even if the input data is
	// incompressible, the kSnappyCompression implementation will
	// efficiently detect that and will switch to uncompressed mode.
	CompressionType compression;

	// EXPERIMENTAL: If true, append to existing MANIFEST and log files
	// when a database is opened.  This can significantly speed up Open.
	//
	// Default: currently false, but may become true later.
	bool reuselogs;

	// Create an Options object with default values for all fields.
	Options();
};

// Options that control read operations
struct ReadOptions {
	// If true, all data read from underlying storage will be
	// verified against corresponding checksums.
	// Default: false
	bool verifychecksums;

	// Should the data read for this iteration be cached in memory?
	// Callers may wish to Set this field to false for bulk scans.
	// Default: true
	bool fillcache;

	// If "snapshot" is non-null, read as of the supplied snapshot
	// (which must belong to the DB that is being read and which must
	// not have been released).  If "snapshot" is null, use an implicit
	// snapshot of the state at the beginning of this read operation.
	std::shared_ptr<Snapshot> snapshot;

	ReadOptions()
		: verifychecksums(true),
		fillcache(true) {

	}
};

// Options that control Write operations
struct WriteOptions {
	// If true, the Write will be flushed from the operating system
	// buffer cache (by calling WritableFile::Sync()) before the Write
	// is considered complete.  If this flag is true, writes will be
	// slower.
	//
	// If this flag is false, and the machine crashes, some recent
	// writes may be lost.  Note that if it is just the process that
	// crashes (i.e., the machine does not reboot), no writes will be
	// lost even if sync==false.
	//
	// In other words, a DB Write with sync==false has similar
	// crash semantics as the "Write()" system call.  A DB Write
	// with sync==true has similar crash semantics to a "Write()"
	// system call followed by "fsync()".
	//
	// Default: false
	bool sync;

	WriteOptions()
		: sync(false) {

	}
};

enum RecordType {
	// Zero is reserved for preallocated files
	kZeroType = 0,

	kFullType = 1,

	// For fragments
	kFirstType = 2,
	kMiddleType = 3,
	kLastType = 4
};

static const int kMaxRecordType = kLastType;

static const int kBlockSize = 32768;

// Header is checksum (4 bytes), length (2 bytes), type (1 byte).
static const int kHeaderSize = 4 + 2 + 1;




